내부 클래스    

클래스 내부에 선언한 클래스로 이 클래스를 감싸고 있는 외부 클래스와 밀접한 연관이 있는 경우가 많고,  
다른 외부 클래스에서 사용할 일이 거의 없는 경우에 내부 클래스로 선언해서 사용한다.  
중첩클래스라고도 한다.  
내부클래스의 종류 : 정적(static) 내부 클래스, 지역(local) 내부 클래스, 익명(anonymous) 내부 클래스    

인스턴스 내부 클래스  
내부적으로 사용할 클래스를 선언(private로 선언하는것을 권장)  
외부 클래스가 생성된 후 생성된다.(정적 내부 클래스와 다름)  
private가 아닌 내부 클래스는 다른 외부 클래스에서 생성할 수 있음.    

정적 내부 클래스  
외부 클래스 생성과 무관하게 사용할 수 있다.  
정적 변수, 정적 메서드 사용.    

지역 내부 클래스  
지역 변수와 같이 메서드 내부에서 정의하여 사용하는 클래스이다.  
메서드의 호출이 끝나면 메서드에 사용된 지역변수의 유효성은 사라진다.  
메서드 호출 이후에도 사용해야 하는 경우가 있을 수 있으므로 지역 내부 클래스에서 사용하는 메서드의 지역 변수나 매개 변수는 final로 선언된다.    

익명 내부 클래스  
이름이 없는 클래스  
클래스의 이름을 생략하고 주로 하나의 인터페이스나 하나의 추상 클래스를 구현하여 반환.  
인터페이스나 추상클래스 자료형의 변수에 직접 대입하여 클래스를 생성하거나 지역 내부 클래스의 메서드 내부에서 생성하여 반환 할 수 있음.    

함수형 인터페이스와 람다식    

함수형 인터페이스는 람다식을 선언하기 위한 인터페이스.  
익명 함수와 매개변수만으로 구현되므로 인터페이스는 단 하나의 메서드만을 선언해야함  
@FunctionalInterface 애노테이션 사용(함수형 인터페이스라는 의미. 내부에 여러 개의 메서드를 선언하면 에러발생)  
자바에서는 객체없이 메서드가 호출될 수 없다.  
람다식을 구현하면 익명 내부 클래스가 만들어지고 이를 통해서 익명 객체가 생성됨    

스트림(Stream)     

자료의 대상과 관계없이 동일한 연산을 수행  
배열, 컬렉션을 대상으로 연산을 수행 함.  
일관성 있는 연산으로 자료의 처리를 쉽고 간단하게 할 수 있다.  
자료 처리에 대한 추상화가 구현되어있다.  
한번 생성하고 사용된 스트림은 재사용 할 수 없다.  
자료에 대한 스트림을 생성하여 연산을 수행하면 스트림은 소모됨.  
다른 연산을 수행하기 위해서는 스트림을 다시 생성해야 한다.  
스트림 연산은 기존 자료를 변경하지 않는다.  
자료에 대한 스트림을 생성하면 스트림이 사용하는 메모리 공간은 별도로 생성되므로 연산이 수행되도 기존 자료에 대한 변경은 발생하지 않는다.  
스트림 연산은 중간 연산과 최종 연산으로 구분된다.  
스트림에 대해 중간 연산은 여러 연산이 적용 될 수 있지만 최종 연산은 마지막에 한꺼번에 적용이 된다.  
최종 연산이 호출되야 중간 연산에 대한 수행이 이루어 지고, 그 결과가 만들어진다.  
따라서 중간 연산에 대한 결과를 연산 중에 알 수 없다.  
이를 "자연 연산"이라고 한다.    

중간연산의 예 : filter(), map(), sorted() 등  
최종연산의 예 : forEach(), count(), sum() 등    

reduce()연산  
정의된 연산이 아닌, 프로그래머가 직접 구현한 연산을 적용할때 사용된다.  
최종연산으로 스트림의 요소를 소모하며 연산을 수행한다.  
reduce() 메서드의 두번째 요소로 전달되는 람다식에 따라 다양한 기능을 수행할 수 있다.  
reduce()연산의 예 ↓  
Arrays.stream(arr).reduce(0, (a,b)->a+b));  
reduce(초기값, (매개변수, 매개변수)->각 요소가 수행해야 할 기능)  
람다식을 직접 구현하거나, 람다식이 긴 경우 BinaryOperator를 구현한 클래스를 사용한다.    

예외처리의 중요성 및 필요성    

컴파일 오류(compile error)및 실행 오류(runtime error)가 발생했을때 프로그램의 비정상적인 종료를 피하여 시스템이 원할이 실행되도록 하기위해서.  
실행 오류가 발생한 경우 오류 과정을 재현하는 것은 현실적으로 어렵기 때문에  
오류가 발생한 경우 log 를 남겨서 추후 log 분석을 통해 그 원인을 파악하여 bug를 수정하는것이 중요하다.    

오류와 예외 클래스  
시스템 오류 : 가상머신에서 발생한다. 프로그래머가 처리 할 수 없는 오류이다.(동적 메모리가 없는 경우, 스택 메모리 오버플로우등)  
예외(exception) : 프로그램에서 제어 할 수 있는 오류  
읽어들이려는 파일이 존재하지 않거나 네트웍이나 DB연결이 안되는경우    

Java에서 예외처리는 try-catch문으로 가능하다.  
try 블록에는 예외가 발생할 가능성이 있는 코드를 작성하고 try블록 안에서 예외가 발생하면 catch 블록이 수행된다.  
catch 블록에서는 예외가 발생했을때 예외를 처리하는 부분을 적으면 된다.    

try-catch-finally 문은 보통  
finally 블럭에서 파일을 닫거나 네트윅을 닫는 등의 리소스 헤제 구현을 해준다  
try 블록이 수행이 되는 경우, finally 블럭은 항상 수행 된다. (return이 있어도 수행됨,)  
여러개의 예외 블럭이 있는 경우 각각에서 리소스를 해제하지 않고 finally블록에서 해제하도록 구현 한다.    

try-with-resources문  
리소스를 사용하는 경우 close() 하지 않아도 자동으로 해제 되도록 해준다.  
자바 7부터 제공되는 구문  
리소스를 try() 내부에서 선언해야만 한다  
close()를 명시적으로 호출하지 않아도 try 블록에서 열린 리소스는 정상적인 경우나 예외가 발생한 경우 모두 자동으로 해제됨.  
해당 리소스 클래스가 AutoCloseable 인터페이스를 구현해야 한다.  
FileInputStream의 경우에는 AutoCloseable을 구현하고 있음.  
자바 9 부터 리소스는 try() 외부에서 선언하고 변수만을 try(obj) 와같이 사용할 수 있다.    

예외처리는 예외가 발생하는 문장에서 try-catch 블록으로 처리하는 방법과 이를 사용하는 부분에서 처리하는 방법 두가지가 있다,  
throws를 사용하면 예외처리가 발생할 수 있는 부분을 사용하는 문장에서 예외를 처리할 수 있다.  
하나의 try블록에서 예외가 여러개 발생하는 경우 catch()문 안에 예외를 묶어서 하나의 방법으로 처리할 수도 있고,  
여러개의 catch() 블록을 이용해 각각의 예외를 따로 처리할 수 있다.    

자바에서 제공되는 예외 클래스외에 프로그래머가 직접 만들어야 하는 예외가 있을 수 있다.  
기존 예외 클래스 중 가장 유사한 예외 클래스에서 상속받아 사용자 정의 예외 클래스를 만든다.  
기본적으로 Exception 클래스를 상속해서 만들 수 있음.    

로그    

logging  
시스템 운영에 대한 기록이다  
오류가 발생했을 때 그 오류에 대한 기록을 남겨 디버깅을 용이하게 할 수 있다.  
로그 파일에 기록하는 코드를 추가하여 필요한 정보가 로그로 남을 수 있도록 한다.  
디버깅, 시스템 에러 추적, 성능, 문제점 향상들을 위해 사용된다.  
너무 적은 로그는 정확한 시스템 상황을 파악하기 어렵고  
너무 많은 로그는 빈번한 file I/O의 오버헤드와 로그 파일의 백업 문제가 있다.  
  
java.util.logging  
자바에서 기본적으로 제공되는 log package이다  
파일이나 콘솔에 로그 내용을 출력할 수 있다.  
jre/lib/logging.properties 파일을 편집하여 로그 출력방식, 로그 레벨을 변경 할 수 있다.  
logging 패키지에서 제공하는 로그 레벨은 Exception상황일때(serve, warning), 정보를 남겨줘야함(info), 별 문제가 없는(config, fine, finer, finest) 이다.  
오픈소스로는 log4j를 많이 사용하고 있다.(최근 보안문제가 발생했지만)    

