# 내부 클래스    

- 클래스 내부에 선언한 클래스로 이 클래스를 감싸고 있는 외부 클래스와 밀접한 연관이 있는 경우가 많고,  
- 다른 외부 클래스에서 사용할 일이 거의 없는 경우에 내부 클래스로 선언해서 사용한다.  
- 중첩클래스라고도 한다.  
- 내부클래스의 종류 : 정적(static) 내부 클래스, 지역(local) 내부 클래스, 익명(anonymous) 내부 클래스    

## 인스턴스 내부 클래스

- 내부적으로 사용할 클래스를 선언(private로 선언하는것을 권장)  
- 외부 클래스가 생성된 후 생성된다.(정적 내부 클래스와 다름)  
- private가 아닌 내부 클래스는 다른 외부 클래스에서 생성할 수 있음.    
-----------------------------
## 정적 내부 클래스  

- 외부 클래스 생성과 무관하게 사용할 수 있다.  
- 정적 변수, 정적 메서드 사용.    
----------------------------
## 지역 내부 클래스  
- 지역 변수와 같이 메서드 내부에서 정의하여 사용하는 클래스이다.  
- 메서드의 호출이 끝나면 메서드에 사용된 지역변수의 유효성은 사라진다.  
- 메서드 호출 이후에도 사용해야 하는 경우가 있을 수 있으므로 지역 내부 클래스에서 사용하는 메서드의 지역 변수나 매개 변수는 final로 선언된다.    
----------------------------
## 익명 내부 클래스  
- 이름이 없는 클래스  
- 클래스의 이름을 생략하고 주로 하나의 인터페이스나 하나의 추상 클래스를 구현하여 반환.  
- 인터페이스나 추상클래스 자료형의 변수에 직접 대입하여 클래스를 생성하거나 지역 내부 클래스의 메서드 내부에서 생성하여 반환 할 수 있음.    
---------------------------
## 함수형 인터페이스와 람다식    

- 함수형 인터페이스는 람다식을 선언하기 위한 인터페이스.  
- 익명 함수와 매개변수만으로 구현되므로 인터페이스는 단 하나의 메서드만을 선언해야함  
- @FunctionalInterface 애노테이션 사용(함수형 인터페이스라는 의미. 내부에 여러 개의 메서드를 선언하면 에러발생)  
- 자바에서는 객체없이 메서드가 호출될 수 없다.  
- 람다식을 구현하면 익명 내부 클래스가 만들어지고 이를 통해서 익명 객체가 생성됨    
--------------------------
# 스트림(Stream)     

- 자료의 대상과 관계없이 동일한 연산을 수행  
- 배열, 컬렉션을 대상으로 연산을 수행 함.  
- 일관성 있는 연산으로 자료의 처리를 쉽고 간단하게 할 수 있다.  
- 자료 처리에 대한 추상화가 구현되어있다.  
- 한번 생성하고 사용된 스트림은 재사용 할 수 없다.  
- 자료에 대한 스트림을 생성하여 연산을 수행하면 스트림은 소모됨.  
- 다른 연산을 수행하기 위해서는 스트림을 다시 생성해야 한다.  
- 스트림 연산은 기존 자료를 변경하지 않는다.  
- 자료에 대한 스트림을 생성하면 스트림이 사용하는 메모리 공간은 별도로 생성되므로 연산이 수행되도 기존 자료에 대한 변경은 발생하지 않는다.  
- 스트림 연산은 중간 연산과 최종 연산으로 구분된다.  
- 스트림에 대해 중간 연산은 여러 연산이 적용 될 수 있지만 최종 연산은 마지막에 한꺼번에 적용이 된다.  
- 최종 연산이 호출되야 중간 연산에 대한 수행이 이루어 지고, 그 결과가 만들어진다.  
따라서 중간 연산에 대한 결과를 연산 중에 알 수 없다.  
이를 "자연 연산"이라고 한다.  
중간연산의 예 : filter(), map(), sorted() 등  
최종연산의 예 : forEach(), count(), sum() 등    
--------------------------------------
## reduce()연산  
- 정의된 연산이 아닌, 프로그래머가 직접 구현한 연산을 적용할때 사용된다.  
- 최종연산으로 스트림의 요소를 소모하며 연산을 수행한다.  
- reduce() 메서드의 두번째 요소로 전달되는 람다식에 따라 다양한 기능을 수행할 수 있다.  
- reduce()연산의 예 ↓  
~~~
Arrays.stream(arr).reduce(0, (a,b)->a+b));  
// reduce(초기값, (매개변수, 매개변수)->각 요소가 수행해야 할 기능)  
~~~
- 람다식을 직접 구현하거나, 람다식이 긴 경우 BinaryOperator를 구현한 클래스를 사용한다.    
------------------------------------
# 예외처리의 중요성 및 필요성    

- 컴파일 오류(compile error)및 실행 오류(runtime error)가 발생했을때 프로그램의 비정상적인 종료를 피하여 시스템이 원할이 실행되도록 하기위해서.  
- 실행 오류가 발생한 경우 오류 과정을 재현하는 것은 현실적으로 어렵기 때문에  
- 오류가 발생한 경우 log 를 남겨서 추후 log 분석을 통해 그 원인을 파악하여 bug를 수정하는것이 중요하다.    
----------------------------------
## 오류와 예외 클래스  
- 시스템 오류 : 가상머신에서 발생한다. 프로그래머가 처리 할 수 없는 오류이다.(동적 메모리가 없는 경우, 스택 메모리 오버플로우등)  
- 예외(exception) : 프로그램에서 제어 할 수 있는 오류  
- 읽어들이려는 파일이 존재하지 않거나 네트웍이나 DB연결이 안되는경우    

- Java에서 예외처리는 try-catch문으로 가능하다.  
- try 블록에는 예외가 발생할 가능성이 있는 코드를 작성하고 try블록 안에서 예외가 발생하면 catch 블록이 수행된다.  
- catch 블록에서는 예외가 발생했을때 예외를 처리하는 부분을 적으면 된다.    

- try-catch-finally 문은 보통  
finally 블럭에서 파일을 닫거나 네트윅을 닫는 등의 리소스 헤제 구현을 해준다  
- try 블록이 수행이 되는 경우, finally 블럭은 항상 수행 된다. (return이 있어도 수행됨,)  
- 여러개의 예외 블럭이 있는 경우 각각에서 리소스를 해제하지 않고 finally블록에서 해제하도록 구현 한다.    
---------------------------------------
## try-with-resources문  
- 리소스를 사용하는 경우 close() 하지 않아도 자동으로 해제 되도록 해준다.  
- 자바 7부터 제공되는 구문  
- 리소스를 try() 내부에서 선언해야만 한다  
- close()를 명시적으로 호출하지 않아도 try 블록에서 열린 리소스는 정상적인 경우나 예외가 발생한 경우 모두 자동으로 해제됨.  
- 해당 리소스 클래스가 AutoCloseable 인터페이스를 구현해야 한다.  
- FileInputStream의 경우에는 AutoCloseable을 구현하고 있음.  
- 자바 9 부터 리소스는 try() 외부에서 선언하고 변수만을 try(obj) 와같이 사용할 수 있다.    

- 예외처리는 예외가 발생하는 문장에서 try-catch 블록으로 처리하는 방법과 이를 사용하는 부분에서 처리하는 방법 두가지가 있다,  
- throws를 사용하면 예외처리가 발생할 수 있는 부분을 사용하는 문장에서 예외를 처리할 수 있다.  
- 하나의 try블록에서 예외가 여러개 발생하는 경우 catch()문 안에 예외를 묶어서 하나의 방법으로 처리할 수도 있고,  
여러개의 catch() 블록을 이용해 각각의 예외를 따로 처리할 수 있다.    

- 자바에서 제공되는 예외 클래스외에 프로그래머가 직접 만들어야 하는 예외가 있을 수 있다.  
- 기존 예외 클래스 중 가장 유사한 예외 클래스에서 상속받아 사용자 정의 예외 클래스를 만든다.  
- 기본적으로 Exception 클래스를 상속해서 만들 수 있음.    
--------------------------------
# 로그    

- logging  
- 시스템 운영에 대한 기록이다  
- 오류가 발생했을 때 그 오류에 대한 기록을 남겨 디버깅을 용이하게 할 수 있다.  
- 로그 파일에 기록하는 코드를 추가하여 필요한 정보가 로그로 남을 수 있도록 한다.  
- 디버깅, 시스템 에러 추적, 성능, 문제점 향상들을 위해 사용된다.  
- 너무 적은 로그는 정확한 시스템 상황을 파악하기 어렵고  
- 너무 많은 로그는 빈번한 file I/O의 오버헤드와 로그 파일의 백업 문제가 있다.  
--------------------------- 
## java.util.logging  
- 자바에서 기본적으로 제공되는 log package이다  
- 파일이나 콘솔에 로그 내용을 출력할 수 있다.  
- jre/lib/logging.properties 파일을 편집하여 로그 출력방식, 로그 레벨을 변경 할 수 있다.  
- logging 패키지에서 제공하는 로그 레벨은 Exception상황일때(serve, warning), 정보를 남겨줘야함(info), 별 문제가 없는(config, fine, finer, finest) 이다.  
- 오픈소스로는 log4j를 많이 사용하고 있다.(최근 보안문제가 발생했지만)    
---------------------------
# 입출력 스트림    

- 네트워크에서 자료의 흐름이 물의 흐름과 같다는 비유에서 유래됨  
- 자바는 다양한 입출력 장치에 독립적으로 일관성 있는 입출력을 입출력 스트림을 통해 제공한다.  
- 입출력이 구현되는 곳 : 파일 디스크, 마우스, 네트윅, 메모리 등 모든 자료가 입력되고 출력되는 곳  
- 하나의 스트림으로 입/출력을 동시에 사용할 수는 없다.  
- 입출력 스트림의 구분  
대상 기준 : 입력 스트림 / 출력 스트림  
자료의 종류 : 바이트 스트림 / 문자 스트림  
바이트 단위 스트림 : 동영상, 음악파일 ,실행파일등의 자료를 읽고 쓸 때 사용한다  
문자 단위 스트림 : 바이트 단위로 자료를 처리하면 문자는 깨진다. 인코딩에 맞게 2바이트 이상으로 처리하도록 구현된 스트림    

- 기능 : 기반 스트림 / 보조 스트림  
기반 스트림 : 대상에 직접 자료를 읽고 쓰는 기능의 스트림  
보조 스트림 : 직접 읽고 쓰는 기능은 없이 추가적인 기능을 더해주는 스트림.  
보조스트림은 직접 읽고 쓰는 기능은 없으므로 항상 기반 스트림이나 또 다른 보조 스트림을 생성자의 매개변수로 포함한다.    
----------------------
# 직렬화(Serialization)    

- 인스턴스의 상태를 그대로 파일 저장하거나 네트윅으로 전송하고 이를 다시 복원하는 방식  
- 자바에서는 보조 스트림을 활용하여 직렬화를 제공한다.    
----------------------
## 직렬화(Serialization) 인터페이스  
- 직렬화는 인스턴스의 내용이 외부로 유출되는 것이므로 프로그래머가 해당 객체에 대한 직렬화 의도를 표시해야 한다.  
- 구현 코드가 없는 make interface  
- transient : 직렬화 하지 않으려는 맴버 변수에 사용함.(Socket 등 직렬화 할 수 없는 객체)    
------------------------------
# 데코레이터 패턴(Decorator Pattern)    

- 자바의 입출력 스트림은 Decorator Pattern 이다.  
- 여러 decorator들을 활용하여 다양한 기능을 제공해준다.  
- 상속보다 유연한 구현 방식  
- 데코레이터는 다른 데코레이터나 또는 컴포넌트를 포함해야 한다.  
- 지속적인 기능의 추가와 제거가 용이함.  
- decorator와 component는 동일하지않다. (기반 스트림 클래스가 직접 읽고 쓸 수 있음. 보조 스트림은 추가적인 기능 제공)    
--------------------------------
# 쓰레드(Thread)    

- process : 실행 중인 프로그램 프로그램이 실행되면 OS로 부터 메모리를 할당받아 프로세스 상태가 됨.  
- thread : 하나의 프로세스는 하나 이상의 thread를 가지게 되고, 실제 작업을 수행하는 단위는 thread이다.    
--------------------------
## 멀티 쓰레딩(Multi-Threading)  
- 여러 thread가 동시에 수행되는 프로그래밍. 여러 작업이 동시에 실행되는 효과가 있다.  
- thread는 각각 자신만의 작업공간을 가진다( context )  
- 각 thread 사이에서 공유하는 자원이 있을 수 있음.( 자바에서는 static instance)  
- 여러 thread가 자원을 공유하여 작업이 수행되는 경우 서로 자원을 차지하려는 race condition이 발생할 수 있음  
- 이렇게 여러 thread가 공유하는 자원 중 경쟁이 발생하는 부분을 critical section이라고 한다.  
- critical section에 대한 동기화(일종의 순차적 수행)를 구현하지 않으면 오류가 발생할 수 있다.    
-----------------------------
## join()  
- 동시에 두 개 이상의 Thread가 실행 될 때 다름 Thread의 결과를 참조하여 실행해야 하는 경우 join()함수를 사용한다.  
- join() 함수를 호출한 Thread가 not-runnable 상대로 간다.  
- 다른 Thread의 수행이 끝나면 runnable 상태로 돌아온다.    
------------------------------
## interrupt()  
- 다른 Thread에 예외를 발생시키는 interrupt 를 보낸다.  
- Thread가 join(), sleep(), wait() 함수에 의해 not-runnable 상태일 때 interrupt() 메서드를 호출하면 다시 runnable상태가 될 수 있다.    
-------------------------
## critical section과 semaphore  
- critical section은 두 개 이상의 thread가 동시에 접근하는 경우 문제가 생길 수 있기 때문에 동시에 접근할 수 없는 영역이다  
- semaphore는 특별한 형태의 시스템 객체이며 get/release 두 개의 기능이 있다.  
- 한 순간 오직 하나의 thread만이 semaphore를 얻을 수 있고 나머지 thread들은 대기(blocking) 상태가 된다.  
- semaphore를 얻은 thread만이 critical section에 들어갈 수 있다.    
--------------------------------
## 동기화 (synchronized)  
- 두개의 thread가 같은 객체에 접근할 경우, 동시에 접근함으로 써 오류가 발생함.  
- 동기화는 임계영역에 접근한 경우 공유자원을 lock하여 다른 thread들의 접근을 제어한다.  
- 동기화를 잘못 구현하면 deadlock에 빠질 수 있다.    
-------------------------
## synchronized 메서드  
- 객체의 메소드에 synchronized 키워드 사용  
- 현재 이 메서드가 속해있는 객체에 lock을 건다.  
- 자바에서는 deadlock을 방지하는 기술이 제공되지 않으므로 되도록이면 synchronized 메서드에서 다른 synchronized 메서드는 호출하지 않도록 한다.    
-------------------------
## wait()/notify() 에서드를 활용한 동기화 프로그래밍  
- 리소스가 어떤 조건에서 더 이상 유효하지 않은 경우 리소스를 기다리기 위해 Thread가 wait() 상태가 된다.  
- wait() 상태가 된 Thread는 notify()가 호출 될 때 까지 기다린다.  
- 유효한 자원이 생기면 notify()가 호출되고 wait() 하고 있는 Thread중 무작위로 하나의 Thread를 재시작 하도록 한다.  
- notifyAll()이 호출되는 경우 wait() 하고있는 모든 Thread가 재시작된다.  
- 이 경우 유효한 리소스만큼의 Thread만이 수행될 수 있고 자원을 갖지 못한 Thread의 경우 다시 wait()상태로 만든다.  
- 자바에서는 notifyAll() 메서드의 사용을 권장한다.    